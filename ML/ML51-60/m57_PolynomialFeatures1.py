import numpy as np
# 3차 함수모양 같은 데이터에 
# 직선 말고 다항식 형태로 그으면 어떨까 싶어서 
# 모델의 선을 변형하는게 아니라 
# X만 건드는 것 
# 2. 모델 구성은 상위권 싸움 
from sklearn.preprocessing import PowerTransformer # 스케일링
from sklearn.preprocessing import PolynomialFeatures

x = np.arange(8).reshape(4,2)
print(x)
pf = PolynomialFeatures(
    degree=3 # 차수가 2야
                        )
x_pf= pf.fit_transform(x)
print(x_pf)
print(x_pf.shape) # (4, 6) # 컬럼의 증폭 개념 
'''
[[ 1.  0.  1.  0.  0.  1.]
 [ 1.  2.  3.  4.  6.  9.]
 [ 1.  4.  5. 16. 20. 25.]
 [ 1.  6.  7. 36. 42. 49.]]
 1열 무조건 1
 2열 1열
 3열 2열
 4열 1열의 제곱
 5열 1열 x 2열의 곱
 6열 2열의 제곱
'''
'''
1열2열
[[0 1]
 [2 3]
 [4 5]
 [6 7]]

[[  1.   0.   1.   0.   0.   1.   0.   0.   0.   1.]
 [  1.   2.   3.   4.   6.   9.   8.  12.  18.  27.]
 [  1.   4.   5.  16.  20.  25.  64.  80. 100. 125.]
 [  1.   6.   7.  36.  42.  49. 216. 252. 294. 343.]]
 1열 무조건 1
 2열 1열
 3열 2열
 4열 1열의 제곱
 5열 1열 x 2열의 곱
 6열 2열의 제곱
 7열 1열의 세제곱
 8열 1열의 제곱 x 2열
 9열 1열 x 2열의 제곱
10열 2열의 세제곱
'''
# 4부터는 잘 사용안하고 조작일 수도 있음

print('=====================컬럼3,degree 3 =======================')

x = np.arange(12).reshape(4,3)
print(x)
pf = PolynomialFeatures(
    degree=2 # 차수가 2야
                        )
x_pf= pf.fit_transform(x)
print(x_pf)
print(x_pf.shape)
'''
x = np.arange(12).reshape(4,3)
[ 1열2열3열
 [ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

 [
 [  1.   0.   1.   2.   0.   0.   0.   1.   2.   4.]
 [  1.   3.   4.   5.   9.  12.  15.  16.  20.  25.]
 [  1.   6.   7.   8.  36.  42.  48.  49.  56.  64.]
 [  1.   9.  10.  11.  81.  90.  99. 100. 110. 121.]]
 
(4, 10)
 1열 무조건 1
 2열 1열
 3열 2열
 4열 3열
 5열 1열의 제곱
 6열 1열 x 2열
 7열 1열 x 3열
 8열 2열의 제곱
 9열 2열 x 3열
10열 3열의 제곱

'''
